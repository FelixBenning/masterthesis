% !TEX root = ../Masterthesis.tex

\newcommand{\identity}{\mathbb{I}}
\newcommand{\lbound}{\mu}
\newcommand{\ubound}{L}
\newcommand{\diag}{\text{diag}}
\newcommand{\rate}{\text{rate}}
\newcommand{\reals}{\mathbb{R}}
\newcommand{\firstOrderMethod}{\mathcal{M}}
\newcommand{\linSpan}{\text{span}}
\newcommand{\dimension}{d}
\newcommand{\loss}{\mathcal{L}}
\newcommand{\weights}{\theta}
\newcommand{\lr}{\text{lr}}
\newcommand{\stdBasis}{e}
\newcommand{\graph}{G}
\newcommand{\graphLaplacian}{A_\graph}
\newcommand{\edges}{E}
\newcommand{\vertices}{V}

\chapter{Gradient Decent (GD)}

A step up from zero order methods (such as grid search) are first order methods
using the first derivative (the gradient). This requires a "first order oracle"
which can provide us with \(\loss(\weights)\) and \(\nabla \loss(\weights)\) at any point
\(\weights\).

One immediately obvious way to utilize this information is to
incrementally move in the direction of steepest decent, i.e.
%
\begin{align*}
	\weights_{n+1} = \weights_n - \lr\nabla \loss(\weights_n).
\end{align*}
%
A useful way to look at this equation is to notice that it is the
discretization of an ordinary differential equation (ODE)
%
\begin{align*}
	\dot{\weights}_n \approx \frac{\weights_{n+1} - \weights_n}{\lr}
	= - \nabla \loss(\weights_n).
\end{align*}
%
Here the "learning rate" \(\lr\) is the time delta between discretizations
\(t_n\) and \(t_{n+1}\). This of course implies \(t_n = n\lr\). And for
\(\lr\to\infty\), we arrive at the ODE
%
\begin{align}\label{eq: velocity is gradient}
	\dot{\weights}(t) = -\nabla \loss(\weights(t)).
\end{align}
%
If you are familiar with Lyapunov functions you will not be surprised by the next
argument:
%
\begin{align}\label{eq: gradient integral}
	\loss(\weights(t_1)) - \loss(\weights(t_0))
	&= \int_{t_0}^{t_1} \nabla \loss(\weights(s)) \cdot \dot{\weights}(s) ds
	= \int_{t_0}^{t_1} -\|\nabla \loss(\weights(s))\|^2 ds
	\le 0
\end{align}
%
immediately implies
\begin{align*}
	\loss(\weights(t_0)) \ge \loss(\weights(t_1)) \ge \dots \ge \inf_\weights \loss(\weights) \ge 0
\end{align*}
which implies convergence. But not necessarily a convergent \(\weights(t)\) and
not necessarily convergence to \(\inf_\weights \loss(\weights)\).

\section{Visualizing the 2nd Taylor Approximation}\label{sec: visualize gd}

To build some intuition what leads to convergence of \(\weights(t)\) let us
consider more simple cases. If we assume our Hesse matrix \(\nabla^2
\loss(\weights)\) exists and is positive definite (all eigenvalues positive), then for
the second order Taylor approximation
%
\begin{align*}
	\loss(\weights+v) \approx T_2\loss(\weights+v)
	= \loss(\weights) + v^T \nabla \loss(\weights) + \tfrac12 v^T \nabla^2 \loss(\weights) v
\end{align*}
%
we can find the minimum 
\begin{align*}
	\hat{v} = -(\nabla^2 \loss(\weights))^{-1}\nabla \loss(\weights)
\end{align*}
by setting the first derivative to zero
%
\begin{align*}
	\nabla T_2\loss(\weights+v) = \nabla \loss(\weights) + \nabla^2\loss(\weights) v \xeq{!} 0.
\end{align*}
%
This minimum allows us not only to rewrite the taylor derivative
%
\begin{align*}
	\nabla T_2\loss(\weights+v) = \nabla^2 \loss(\weights)(v-\hat{v}),
\end{align*}
%
but also the original taylor approximation
%
\begin{align*}
	T_2\loss(\weights+v)
	&= \loss(\weights) - v^T \nabla^2 \loss(\weights) \hat{v} + \tfrac12 v^T \nabla^2 \loss(\weights) v \\
	&= \underbrace{
		\loss(\weights) - \tfrac12 \hat{v} \nabla^2 \loss(\weights) \hat{v}
	}_{
		=: c(\weights) \text{ (const.)}
	} + \tfrac12 (v-\hat{v})^T \nabla^2 \loss(\weights)(v-\hat{v}).
\end{align*}
%
To get absolute instead of relative coordinates to \(\weights\) we set
%
\begin{align*}
	\hat{\weights} := \weights + \hat{v} = \weights -(\nabla^2 \loss(\weights))^{-1}\nabla \loss(\weights),
\end{align*}
%
and obtain the notion of a paraboloid centered around \(\hat{\weights}\)
%
\begin{align}\label{paraboloid approximation of L}
	\loss(y)
	= \tfrac12 (y- \hat{\weights}) \nabla^2 \loss(\weights) (y-\hat{\weights})
	+ c(\weights) + o(\|y-\weights\|^2)
\end{align}
%
\begin{wrapfigure}{O}{0.65\textwidth}
	\centering
	\def\svgwidth{0.65\textwidth}
	\input{media/contour.pdf_tex}
	\caption{Assuming \(\hat{\weights}=0\), \(\lambda_1=1, \lambda_2=2\), \(v_1=(\sin(1), \cos(1))\)}
	\label{fig: 2d paraboloid}
\end{wrapfigure}
%
To fully appreciate Figure~\ref{fig: 2d paraboloid}, we now only need to realize
that the diagonizability of \(\nabla^2 \loss(\weights)\)
%
\begin{align}\label{eq: diagnalization of the Hesse matrix}
	V \nabla^2 \loss(\weights) V^T
	= \diag(\lambda_1,\dots,\lambda_d), \qquad V=(v_1,\dots, v_d)
\end{align}
%
implies that once we have selected the center \(\hat{\weights}\) and the direction of
one eigenspace in two dimensions, the other eigenspace has to be
orthogonal to the first one which fully determines its direction at this point. 

Before we move on I want to briefly mention that we only really needed the
positive definiteness of \(\nabla^2 \loss(\weights)\) to make it invertible, so that
\(\hat{v}\) is well defined. If it was not positive definite but still invertible,
then \(\hat{v}\) would not be a minimum but all the other arguments would still
hold.
In that case the eigenvalues might be negative as well as positive, which would
represent a saddle point, or all negative which would represent a maximum.

Using the representation (\ref{paraboloid approximation of L}) of \(\loss\) we
can write the gradient at \(\weights\) as
%
\begin{align*}
	\nabla \loss(\weights)
	=  \nabla^2 \loss(\weights)(\weights-\hat{\weights})
	\ (= -\nabla^2 \loss(\weights)\hat{v})
\end{align*}
%
But note that \(\hat{\weights}\) depends on \(\weights\), so we need to index both
by \(n\) to rewrite gradient decent
%
\begin{align*}
	\weights_{n+1} &= \weights_n - \lr\nabla \loss(\weights_n)\\
	&= \weights_n - \lr\nabla^2 \loss(\weights_n)(\weights_n - \hat{\weights}_n).
\end{align*}
%
Subtracting \(\hat{\weights}_n\) from both sides we obtain the following
transformation 
%
\begin{align}\label{eq: Matrix GD Formulation}
	\weights_{n+1} - \hat{\weights}_n
	&= (\identity - \lr\nabla^2 \loss(\weights_n) ) (\weights_n - \hat{\weights}_n).
\end{align}
%
Taking a closer look at this transformation matrix we can use (\ref{eq:
diagnalization of the Hesse matrix}) to see
%
\begin{align*}
	\identity - \lr\nabla^2 \loss(\weights_n)
	&= V(\identity - \lr\cdot\diag(\lambda_1,\dots,\lambda_d) )V^T \\
	&= V\cdot\diag(1-\lr\lambda_1, \dots,1-\lr\lambda_d)V^T.
\end{align*}
%
Now if we assume like \textcite{gohWhyMomentumReally2017}, that the second
taylor approximation is accurate and thus that \(\nabla^2 \loss(\weights)=H\) is a
constant, then \(\hat{\weights}_n = \weights^*\) is the real minimum and we get
%
\begin{align}
	\weights_n - \weights^*
	= V\cdot\diag[(1-\lr\lambda_1)^n,\dots,(1-\lr\lambda_d)^n] V^T (\weights_0 - \weights^*)
\end{align}
%
by induction. Decomposing the difference into the eigenspaces of \(H\) we can 
see that each component scales exponentially on its own 
%
\begin{align*}
	\langle \weights_n -\weights^*, v_i\rangle
	= (1-\lr\lambda_i)^n \langle \weights_0 - \weights^*, v_i\rangle
\end{align*}
%
This is beautifully illustrated with interactive graphs in
\citetitle{gohWhyMomentumReally2017} by \citeauthor{gohWhyMomentumReally2017}.

\subsection{Negative Eigenvalues}\label{subsec: Negative Eigenvalues}

Now if \(\lambda_i<0\), then \(1-\lr\lambda_i\) would be greater
than one which would repel this component \(\langle \weights_0 - \weights^*,
v_i\rangle\) away from \(\weights^*\). This is a good thing, since \(\weights^*\)
is a maximum in this component. This means we will walk down local minima and
saddle points no matter the learning rate assuming  this component  was not
zero to begin with. In case of a maximum this would mean that we would start
right on top of the maximum, in case of a saddle point it implies starting on
the rim such that one can not roll down either side.

But since we are ultimately interested in stochastic loss functions, the
stochasticity would push us off these narrow equilibria so being right on
top of them is of little concern. But being close to zero in such a component
still means slow movement away, since we are multiplying by it. This is a
common explanation for the observation of temporary plateaus in machine learning
which "suddenly fall off" once the exponential factor ramps up and causes a
sharp drop in the loss (Figure~\ref{fig: visualize saddlepoint gd}).
%
\begin{figure}[h]
	\centering
	\def\svgwidth{1\textwidth}
	\input{media/visualize_gd.pdf_tex}
	\caption{Start=\(0.001v_1+4v_2\), \(\lambda_1=-1, \lambda_2=2\), learning rate\(=0.8\)}
	\label{fig: visualize saddlepoint gd}
\end{figure}

\subsection{Assuming Convexity}

Let us consider strictly positive eigenvalues now and assume that our
eigenvalues are already sorted
%
\begin{align}
	0 < \lambda_1 \le \dots \le \lambda_d.
\end{align}
%
Then for positive learning rates all exponentiation bases are smaller than one
%
\begin{align*}
	1-\lr\lambda_d \le \dots \le 1-\lr\lambda_1 \le 1.
\end{align*}
%
But to ensure convergence we also need that all of them are larger than \(-1\).
This leads us to the condition
\begin{align}\label{eq: learning rate restriction (eigenvalue)}
	0< \lr < 2/\lambda_d
\end{align}
%
Selecting \(\lr = 1/\lambda_d\) reduces the exponentiation base ("rate") of the
corresponding eigenspace to zero ensuring convergence in one step.
But if we want to maximize the convergence rate of \(\weights_n\), this is not
the best selection.

We can reduce the rates of the other eigenspaces if we
increase the learning rate further, getting them closer to zero. At this point
we are of course overshooting zero with the largest learning rate, so we only
continue with this until we get closer to \(-1\) with the largest eigenvalue
than we are to \(1\) with the smallest:
%
\begin{align*}
	\rate(\lr)=\max_{i} |1-\lr\lambda_i| = \max\{|1-\lr\lambda_1|, |1-\lr\lambda_d|\}.
\end{align*}
%
This is minimized when
%
\begin{align*}
	1-\lr\lambda_1 = \lr\lambda_d -1,
\end{align*}
%
implying
%
\begin{align*}
	\lr^* = \frac{2}{\lambda_1 + \lambda_d}.
\end{align*}
%
If \(\lambda_1\) is much smaller than \(\lambda_d\), this leaves \(\lr\)
at the upper end of the interval in (\ref{eq: learning rate restriction
(eigenvalue)}). And the optimal convergence rate
%
\begin{align*}
	\rate(\lr^*)
	% &= 1-\lr^* \lambda_1
	= 1 - \frac{2}{1+\kappa}
	\qquad \kappa:=\lambda_d/\lambda_1 \ge 1
\end{align*}
%
becomes close to one if the condition number \(\kappa\) is large.
If all the eigenvalues are the same on the other hand, the condition number
becomes one and the rate is zero, implying instant convergence. This is not
surprising if we recall our visualization in Figure~\ref{fig: 2d paraboloid}.
When the eigenvalues are the same, the contours are concentric circles and the
gradient points right at the center.

\fxnote{strong convexity and lipshitz continuity of gradient as lower and
upper bound, sketch convergence proof using that instead of eigenvalues}

\section{Generalizing Assumptions}

Let us try to get rid of the assumptions we made in \ref{sec: visualize gd}.
The most egregious assumption was a constant second derivative. We used this
constant second derivative to determine the (constant) condition number of
the (constant) eigenvalues. Since we used only the smallest and largest
eigenvalue, it is natural to guess that simply bounding the second derivative
from above and below should be sufficient:
%
\begin{align*}
	\lbound \identity \precsim \nabla^2 \loss(\weights) \precsim \ubound \identity.
\end{align*}
%
Here \(A \precsim B\) should be read as \(0\precsim B-A\) which we define to mean
\(B-A\) is positive definite.

\subsection{Convexity}

Assuming positive eigenvalues is assuming convexity, and there is not really a
way around that. As we have seen in Subsection~\ref{subsec: Negative
Eigenvalues}, negative eigenvalues act as a repelling force, preventing the
transformation (\ref{eq: Matrix GD Formulation}) from being a contraction.

For this reason authors generally assume either global convexity, or local
convexity together with the assumption that the starting point is in this
locally convex area. This is a reasonable assumption since the negative
eigenvalues mentioned above will force us out of regions where this is not
the case. And if we assume that our loss function \(\loss\) goes to infinity when
our parameters go to infinity, together with the fact that we are descending
down the loss, then we immediately get a bounded (compact) area 
%
\begin{align*}
	\{\weights : \loss(\weights) \le \loss(\weights_0)\} = \loss^{-1}([0, \loss(\weights_0)])
\end{align*}
%
in which we will stay. We can use that boundedness to argue that we will
eventually end up in a convex region if we are pushed out of the non-convex
regions.

That such a convex region exists follows from the existence of a minimum of
\(\loss\) in that compact region which necessitates non-negative
eigenvalues. And continuity of the second derivative allows us to extend that to 
a local ball around the minimum. Eigenvalues equal to zero
are a bit of an issue, but if they become negative in some epsilon ball
then moving in that direction would lead us further down. Which is a contradiction
to our assumption that we created a ball around the minimum of \(\loss\).

The statement that we are being pushed out of the non-convex regions is a bit
dubious as we could start right on top of local maxima or rims of saddle points.
But as we are ultimately interested in stochastic gradient decent, these zero
measure areas are of little concern. But as we already found out in
Subsection~\ref{subsec: Negative Eigenvalues}, starting close to such a feature
increases the amount of time it takes for us to escape that area which means
we can not really provide an upper bound on the time it takes to end up in
a locally convex area.

So the best we can do without actually getting into probability theory is to
hand-wave this starting phase away with the unlikelihood of it taking too long
due to the exponential repulsion from negative eigenvalues.

In the following we are therefore going to assume convexity. A formulation which
does not require the second derivative is
%
\begin{definition}[Convexity]
	A function \(f\) is called \emph{convex}, if for all \(x,y\), \(\lambda\in[0,1]\)
	\begin{align*}
		f(x + \lambda(y-x)) \le f(x) + \lambda (f(y)-f(x)).
	\end{align*}
	If \(f\) is differentiable this is equivalent to the tangent being below
	the function itself
	\begin{align*}
		f(x) + \langle\nabla f(x), y-x\rangle \le f(y).
	\end{align*}
	If \(f\) is twice differentiable then this is equivalent to
	\begin{align*}
		0\precsim\nabla^2 f.
	\end{align*}
 \end{definition}
%
\begin{figure}[h]
	\centering
	\def\svgwidth{1\textwidth}
	\input{media/visualize_convexity.pdf_tex}
	\caption{Visualize Convexity Definitions}
	\label{fig: visualize convexity definition}
\end{figure}
%
\begin{proof}
	For the equivalence of these convexity definitions see \textcite[Theorem
	2.1.2, 2.1.4]{nesterovLecturesConvexOptimization2018}\fxnote{appendix?}
 \end{proof}
%
\begin{remark}
	Now if you recall how the rate of convergence was related to the condition number
	\(\lambda_d/\lambda_1 =\kappa\), then you will not be surprised to see us 
	struggle to get a convergence rate with only non-negative eigenvalues in 
	the remaining section. Because eigenvalues close or equal to zero will blow up this
	condition number. We will therefore strengthen these assumptions in
	Section~\ref{sec: Strong Convexity} but we can actually make a few assertions
	with convexity only.
\end{remark}

\subsection{Lipschitz Gradient}

We still need a replacement for the upper bound of our second derivative.
Using the orthonormal basis of eigenvectors of
\(\nabla^2 \loss(\weights)\) to represent \(x\) in the definition of the operator norm
%
\begin{align*}
	\|A\| := \sup_{\|x\| =1} \|Ax\|
	\left(= \sup_{\|x\| =1} \sqrt{\langle Ax, Ax\rangle}\right)
\end{align*}
%
it becomes immediately clear that the operator norm is equal to the largest
absolute eigenvalue. This implies that for positive eigenvalues 
%
\begin{align}
	\label{eq: operator norm upper bound relation}
	\nabla^2 \loss(\weights) \precsim \ubound\identity
	\iff \|\nabla^2 \loss(\weights)\|\le \ubound,
\end{align}
%
and the following lemma allows us to get rid of the existence of the second
derivative for the upper bound entirely
%
\begin{lemma}\label{lem: lipschitz and bounded derivative}
	If \(f\) is differentiable, then the derivative \(\nabla f\) is
	bounded (w.r.t. the operator norm) by constant \(K\)
	\begin{align*}
		\|\nabla f\| \le K
	\end{align*}	
	if and only if the function
	\(f\) is Lipschitz continuous (Lip. constant \(K\))
	\begin{align*}
		\|f(x) - f(y)\| \le K \|x-y\|.
	\end{align*}
\end{lemma}
\begin{proof}
	See Appendix \ref{Appdx-lem: lipschitz and bounded derivative}.
\end{proof}
%
\noindent
So instead of the upper bound on the second derivative we can use Lipschitz
continuity of the derivative and convexity to formulate the upper and lower
bound without actually using the derivative.

Now we have to ask ourselves whether this  is a reasonable assumption. There
are two somewhat convincing reasons why there is probably not much more space
for generalization.

First, we are using our derivative to define an ODE (\ref{eq: velocity is
gradient}) and it is very common to use Lipschitz continuity to argue for
existence, uniqueness and stability of ODEs. While these properties might not
be needed for effective optimization, working without them will likely be very
cumbersome.

Second, we need at least uniform continuity of \(\nabla \loss\) so that the inequality
%
\begin{align}\label{eq: bounded gradient integral}
	\int_{t_0}^\infty \|\nabla \loss(\weights(s))\|^2 ds
	&\le \loss(\weights(t_0)) - \liminf_{t\to\infty} \loss(\weights(t)) \\
	&\le \loss(\weights(t_0)) - \inf_{\weights} \loss(\weights) < \infty \nonumber
\end{align}
%
derived from (\ref{eq: gradient integral}) is sufficient for a convergent
\(\|\nabla \loss(\weights(t))\|\). That still does not ensure that \(\weights(t)\)
converges, only that its derivative \(\dot{\weights}(t) = -\nabla \loss(\weights(t))\)
converges. The logarithm is an obvious example where this goes wrong. But
while it is not sufficient, the difference between \(\weights_{n+1}\) and
\(\weights_n\) is proportional to the gradient. Convergence of the gradient is
therefore necessary.
So let us see if we can get convergence of the discrete gradients as well.
%
\begin{lemma}[\cite{nesterovLecturesConvexOptimization2018}]
	\label{lem: Lipschitz Gradient implies taylor inequality}
	Assume \(\nabla f\) is Lipschitz continuous with Lipschitz constant \(K\),
	then we have
	\begin{align*}
		| f(y) - f(x) - \langle \nabla f(x), y-x\rangle | \le \tfrac{K}2 \|y-x\|^2
	\end{align*}
\end{lemma}
\begin{proof}
	See Appendix \ref{Appdx-lem: Lipschitz Gradient implies taylor inequality}.
\end{proof}
%
\noindent
Using the Lipschitz continuity of the gradient and Lemma~\ref{lem: Lipschitz
Gradient implies taylor inequality} we get
%
\begin{align}
	\loss(\weights_{n+1})
	&\le \loss(\weights_n) 
	+ \langle\nabla \loss(\weights_n),\weights_{n+1} - \weights_n\rangle
	+ \tfrac{\ubound}{2} \| \weights_{n+1} - \weights_n\|^2 
	\label{bound increment}\\
	&= \loss(\weights_n)
	+ \langle\nabla \loss(\weights_n), -\lr\nabla \loss(\weights_n)\rangle
	+ \tfrac{\ubound}{2}\lr^2\| \nabla \loss(\weights_n)\|^2
	\nonumber\\
	&=\loss(\weights_n) - \lr(1-\tfrac{\lr \ubound}{2})\|\nabla \loss(\weights_n)\|^2
	\nonumber
\end{align}
%
We can then parametrize all learning rates for which we can guarantee a positive
decrease by
\begin{align}\label{learning rate restrictions}
	0<\lr=\tfrac{2\alpha}{\ubound}<\tfrac2\ubound \qquad \alpha \in (0,1).
\end{align}
%
This is the same bound we have encountered in the simplified case (\ref{eq:
learning rate restriction (eigenvalue)}) which tells us that there are no more
gains to be made. Plugging the parametrization back into the learning rate we
get
%
\begin{align*}
	\loss(\weights_{n+1}) - \loss(\weights_n)
	\le - \tfrac{2}{\ubound}\alpha (1-\alpha)\|\nabla \loss(\weights_n)\|^2.
\end{align*}
%
The largest decrease is guaranteed by \(\lr=\tfrac{1}{\ubound}\) (\(\alpha=1/2\)).
\begin{remark}
	Recall that this sets the rate of the largest eigenvalue to zero eliminating
	the error in that eigenspace immediately, but it is not the optimal
	discretization for \(\weights\) to move towards a minimum in parameter space.
	But here we do not care about the distance in parameter space but the
	distance between the losses. And favouring the eigenspace with larger
	eigenvalues is results in greater reductions in the loss.
\end{remark}
This results in
%
\begin{align*}
	\loss(\weights_{n+1}) - \loss(\weights_n)
	\le - \tfrac{1}{2\ubound}\|\nabla \loss(\weights_n)\|^2.
\end{align*}
%
\subsubsection{Dead End: Convergence of the Gradient}

Summing over these increments results in a very similar equation to
(\ref{eq: bounded gradient integral})
%
\begin{align*}
	\frac{1}{2\ubound} \sum_{k=0}^{n-1}\|\nabla \loss(\weights_k)\|^2
	\le \loss(\weights_0) - \loss(\weights_n)
	\le \loss(\weights_0) - \inf_{\weights} \loss(\weights)
\end{align*}
%
Since \(\tfrac{1}{\ubound}\) is the time increment \(\lr\) between the \(\weights_k\)
we have only lost the factor \(1/2\) in our estimation (\ref{bound increment})
compared to the precise integral version.
In particular we get a convergent average of squared gradients
%
\begin{align*}
	\frac{1}{n} \sum_{k=0}^n \|\nabla \loss(\weights_k)\|^2
	\le \frac{2 \ubound}{n} (\loss(\weights_0) - \inf_\weights \loss(\weights)) \in O(1/n).
\end{align*}
%
It is important to note the "square" part. If the series of unsquared gradient
norms were finite as well, the \(\weights_n\) would be a cauchy sequence
%
\begin{align*}
	\|\weights_n - \weights_m \|
	\le \sum_{k=m}^{n-1} \|\weights_{k+1} - \weights_k\|
	\le \lr \sum_{k=m}^{n-1} \|\nabla \loss(\weights_k)\|.
\end{align*}
%
This provides us with some intuition how a situation might look like when the
gradient converges but not the sequence of \(\weights_n\). The gradient would
behave something like the harmonic series, as its squares converges and the
\(\weights_n\) would behave like the partial sums of the harmonic series which
behaves like the logarithm in the limit.

It is difficult to formulate an example in finite space, but
%
\begin{align*}
	\loss(\weights) &= \exp(-\weights) \\
	\dot{\weights} &= -\nabla \loss(\weights)
\end{align*}
%
implies
%
\begin{align*}
	\weights(t) &= \log(t)\\
	\nabla \loss(t) &= -\tfrac1t
\end{align*}
%
which provides intuition how "flat" a minima has to be to cause such behavior.
The minimum at \(\infty\) has an infinitely wide basin which flattens out
more and more. If we wanted such an example in a bounded space we would have
to try and coil up such an infinite slope into a spiral, which spirals outwards
to avoid convergence.

Since our example is one dimensional we can also immediately see the "eigenvalue"
%
\begin{align*}
	\nabla^2 \loss(\weights(t)) = \exp(-\weights(t)) = 1/t
\end{align*}
%
which decreases towards zero, stalling the movement towards the minimum.

\subsection{Convergence Theorems}\label{sec: convex convergence theorems}

While we do need lower bounds on the second derivative to achieve convergence
of \(\weights(t)\) as motivated in the previous section we can get convergence
of the loss

\begin{theorem}[\cite{nesterovLecturesConvexOptimization2018}]
	Let \(\loss\) be convex, differentiable with Lipschitz gradient, then Gradient
	Decent with learning rate \(0 < \lr < 2/\ubound\) results in
	\begin{align*}
		\loss(\weights_n) - \inf_\weights \loss(\weights)
		\le \frac{2\ubound\|\weights_0 - \weights^*\|}{4 + n\ubound\lr(2-\ubound\lr)}
		\in O(1/n)
	\end{align*}
	with the optimal rate of convergence being achieved for \(\lr=1/\ubound\).
\end{theorem}
\begin{proof}
	See \textcite[Theorem 2.1.14, Corollary
	2.1.2]{nesterovLecturesConvexOptimization2018}
\end{proof}

\fxnote{More extensive treatment?}{
And if we can not have convergence of the parameters \(\weights\) we might not
care as much about the convergence of the gradient either. In that case it
turns out that we can even get convergence of the loss if we only assume
Lipschitz continuity of \(\loss\) itself. But this form of "Subgradient Decent"
requires a bounded, convex parameter set we project back into if we leave and
a decreasing learning rate. And since we can not guarantee a monotonic decrease
with subgradients, the name "decent" is generally avoided and we have to keep
a running minimum. See \textcite[Section 3.2.3]{nesterovLecturesConvexOptimization2018}
or \textcite[Section 3.1]{bubeckConvexOptimizationAlgorithms2015} for a proper
treatment. The convergence rate is not only dependent on the size of the
parameter set \(B\) but it also decreases to \(O(B/\sqrt{n})\).
}

\section{Strong Convexity}\label{sec: Strong Convexity}

To get convergence of the iterate we need to reintroduce a lower bound on
the second derivative. As you might recall from Lemma~\ref{lem: Lipschitz
Gradient implies taylor inequality}, a Lipschitz continuous gradient implies
a quadratic function provides an upper bound for our loss function
%
\begin{align}\label{eq: upper bound}
	\loss(y) \le \loss(x) + \langle \nabla \loss(x), y-x\rangle + \frac\ubound{2}\|y-x\|^2.
\end{align}
%
And convexity was defined as a lower bound
%
\begin{align*}
	\loss(x) + \langle \nabla \loss(x), y-x\rangle \le \loss(y)
\end{align*}
%
which we will now sharpen this to a quadratic lower bound as well.
%
\begin{definition}
	A function \(\loss\) is \emph{strongly convex}, if for all \(x,y\)
	\begin{align*}
		\loss(x) + \langle \nabla \loss(x), y-x\rangle + \frac{\lbound}{2}\|y-x\|^2 \le \loss(y)
	\end{align*}
\end{definition}
%
\begin{figure}[h]
	\centering
	\def\svgwidth{1\textwidth}
	\input{media/visualize_strong_convexity.pdf_tex}
	\caption{Strong Convexity provides a tighter lower bound}
	\label{fig: visualize strong convexity}
\end{figure}
%
Using this new assumption we get our linear\footnote{
	In the Numerical Analysis, exponential rate of
	convergence is called "linear convergence" because the relationship
	\[
		\|\weights_{n+1} - \weights^*\| \le c \|\weights_n - \weights^*\|
	\]
	is linear. In
	general convergence order \(q\) implies 
	\[
		\|\weights_{n+1} -\weights^*\| \le c\|\weights_n - \weights^*\|^q.
	\]
	This is because quadratic convergence (\(q=2\)) already results in an actual
	rate of convergence of \(c^{\left(2^n\right)}\) which is double exponential and
	repeated application of \(\exp\) is annoying to write so writers prefer the
	recursive notation above which motivates this seemingly peculiar naming.
	The convergence rate we obtained in Section~\ref{sec: convex convergence theorems}
	is therefore referred to as "sub-linear" convergence.
}
rate of convergence back, which we had motivated in Section~\ref{sec: visualize gd}. 
%
\begin{theorem}[\cite{nesterovLecturesConvexOptimization2018}]
	If \(\loss\) is strongly convex, differentiable with Lipschitz gradient, then
	for learning rate
	\[0 \le \lr \le \frac{2}{\ubound+\lbound}\]
	Gradient Decent generates a sequence \(\weights_n\) satisfying
	\begin{subequations}
	\begin{align}
		\label{eq: gd strong convexity convergence rate 1}
		\|\weights_n - \weights^*\|
		&\le \left(
			1- 2\lr\frac{\ubound\lbound}{\ubound+\lbound}
		\right)^{n/2}
		\|\weights_0 - \weights^*\| \\
		\label{eq: gd strong convexity convergence rate 2}
		\loss(\weights_n) - \loss(\weights^*)
		&\le \frac\ubound{2} \left(
			1- 2\lr\frac{\ubound\lbound}{\ubound+\lbound}
		\right)^{n}
		\|\weights_0 - \weights^*\|^2
	\end{align}
	\end{subequations}
	In particular for \(\lr=\tfrac2{\ubound+\lbound}\) we achieve the optimal
	rate of convergence
	\begin{subequations}\label{eq: gd strong convexity optimal rate}
	\begin{align}
		\|\weights_n - \weights^*\|
		&\le \left(
			1- \frac{2}{1+\kappa}
		\right)^n
		\|\weights_0 - \weights^*\| \\
		\loss(\weights_n) - \loss(\weights^*)
		&\le \frac\ubound{2} \left(
			1- \frac{2}{1+\kappa}
		\right)^{2n}
		\|\weights_0 - \weights^*\|^2
	\end{align}
	\end{subequations}
\end{theorem}
\begin{proof}[Proof {\parencite[Theorem 2.1.15]{nesterovLecturesConvexOptimization2018}}]
	\begin{align*}
		\|\weights_{n+1} - \weights^*\|^2
		&= \| \weights_n -\weights^* - \lr\nabla\loss(\weights_n)\|^2\\
		&= \| \weights_n - \weights^*\|^2
		- 2\lr\langle \nabla\loss(\weights_n), \weights_n - \weights^*\rangle
		+ \lr^2 \| \nabla\loss(\weights_n)\|^2
	\end{align*}
	Using \(\nabla\loss(\weights^*)=0\) and \fxwarning{appendix!}{\ref{??}}
	\begin{align*}
		&\langle \nabla\loss(\weights_n) -\nabla\loss(\weights^*), \weights_n - \weights^*\rangle	\\
		&\ge \tfrac{\ubound\lbound}{\ubound+\lbound}\|\weights_n - \weights^*\|^2
		+ \tfrac{1}{\ubound+\lbound}
		\|\nabla\loss(\weights_n) - \nabla\loss(\weights^*)\|^2
	\end{align*}
	we get
	\begin{align*}
		\|\weights_{n+1} - \weights^*\|^2
		\le \left(1- 2\lr \tfrac{\ubound\lbound}{\ubound+\lbound}\right)
		\|\weights_n - \weights^*\|^2
		+ \underbrace{\lr}_{\ge 0}
		\underbrace{\left(\lr-\tfrac{2}{\ubound+\lbound}\right)}_{\le0}
		\|\nabla\loss(\weights_n)\|^2
	\end{align*}
	which using induction proves (\ref{eq: gd strong convexity convergence rate
	1}). (\ref{eq: gd strong convexity convergence rate 2}) follows from our
	upper bound (\ref{eq: upper bound}), i.e. Lipschitz continuity of the gradient:
	\begin{align*}
		\loss(\weights_n) - \loss(\weights^*)
		\le \langle \underbrace{\nabla\loss(\weights^*)}_{=0}, \weights_n - \weights^*\rangle
		+ \tfrac\ubound{2} \| \weights_n - \weights^*\|^2
	\end{align*}
	To get (\ref{eq: gd strong convexity optimal rate}) we simply have to plug
	in the presumed optimal learning rate \(\lr=2/(\ubound+\lbound)\) into
	our general rate and show that the rate is still positive which means that
	we have not overshot zero, which means that the upper bound on our learning
	rate which we presume to be optimal is binding:
	\begin{align*}
		\left(1- 4 \frac{\ubound\lbound}{(\ubound+\lbound)^2}\right)
		= \frac{(\ubound^2 + 2\ubound\lbound + \lbound^2) - 4 \ubound\lbound}{(\ubound+\lbound)^2}
		= \left(\frac{\ubound-\lbound}{\ubound+\lbound}\right)^2
	\end{align*}
	To get the representation in (\ref{eq: gd strong convexity optimal rate}) we
	only have to add and subtract one inside the bracket and cancel out
	\(\lbound\) from enumerator and denominator.
\end{proof}

While it is not too surprising that we recovered the learning rate from
Section~\ref{sec: visualize gd} as we simply provided lower and upper bounds on
the eigenvalues, it is still reassuring. 

\section{Complexity Bounds}

Now that we found convergence rates for gradient decent on (strongly) convex
problems, the question is can we do better? I.e. how fast could an algorithm we
could possibly think of be? To tackle this problem let us first make an
assumption about what this algorithm can do.
Unrolling our gradient decent algorithm
%
\begin{align*}
	\weights_n = \weights_0 - \lr\sum_{k=0}^{n-1} \nabla \loss(\weights_k)
\end{align*}
%
we can see that even if we allowed custom learning rates for every iteration
%
\begin{align*}
	\weights_n = \weights_0 - \sum_{k=0}^{n-1} \lr_k \nabla \loss(\weights_k)
\end{align*}
%
we would still end up in the linear span of all gradients, shifted by \(\weights_0\).
And since we are in the class of first order optimization methods where we are
only provided with the function evaluation itself and the gradient, an obvious
assumption for a class of optimization methods would be
%
\begin{assumption}[\citeauthor{nesterovLecturesConvexOptimization2018}]
	\label{assmpt: parameter in linear hull of gradients}
	The \(n\)-th iterate of the optimization method is contained in the span of all
	previous gradients shifted by the initial starting point
	\begin{align*}
		\weights_n \in \linSpan\{\nabla \loss(\weights_k) : 0\le k \le n-1\} + \weights_0
	\end{align*}
\end{assumption}
%
Now the question becomes: How can we utilize this assumption to construct a
function which is difficult to optimize?
\textcite{gohWhyMomentumReally2017} provides an intuitive interpretation for a loss
function taken from \textcite[Section 2.1.2]{nesterovLecturesConvexOptimization2018}
which I further modify into the following example.

\begin{figure}[h]
	\centering
	\def\svgwidth{1\textwidth}
	\input{media/visualize_coloring_problem.pdf_tex}
	\caption{Even after \(\dimension\) steps (when all tiles have a non-zero value)
	gradient decent is still far off from the solution even using the optimal
	learning rate \(1/\ubound\)}
	\label{fig: visualize coloring problem}
\end{figure}
%
Consider an empty elongated swimming pool with a running tap on one side. Then
the second meter of the swimming pool will only start to get wet once the first
meter of it contains water. Similarly the \(n\)-th meter will only get wet
once the \((n-1)\)-th meter contains water. If the flow rate would only depend
on the current water level difference, one could thus express a simplified
water level recursion as follows\footnote{
	In the limit (first taking the learning rate to zero, then the
	discretization) this would become the well known differential equation for
	heat.
}: 
%
\begin{align*}
	\weights_{n+1}^{(i)}
	&= \weights_{n}^{(i)}
	+ \lr 
	\begin{cases}
		[\weights_{n}^{(i-1)} - \weights_{n}^{(i)}] + [\weights_{n}^{(i+1)} - \weights_{n}^{(i)}]
		&  1 < i < \dimension \\
		[1 - \weights_{n}^{(1)}] + [\weights_{n}^{(2)} - \weights_{n}^{(1)}]
		& i = 1 \\
		[\weights_{n}^{(i-1)} - \weights_{n}^{(i)}]
		& i = \dimension
	\end{cases}
\end{align*}
%
For the \fxnote{appendix?}{(convex)} loss function
%
\begin{align*}
	\loss(\weights)
	= \frac12 (\weights^{(1)}-1)^2
	+ \frac12 \sum_{k=1}^{\dimension-1} (\weights^{(k)}-\weights^{(k+1)})^2
\end{align*}
%
this is just the gradient decent recursion. Now here is the crucial insight:

Since any weight (parameter component) is only affected once its neighbors are
affected, the second weight can not be affected before the second step since
the first weight is only filled in the first step. And since the second weight
will be unaffected until the second step, the third weight will be unaffected
until the third step, etc.

Therefore the \(\dimension - n\) last components will still be zero in
step \(n\), because the linear span of all the gradients so far is still
contained in the subspace \(\reals^n\) of \(\reals^\dimension\). Formalizing
this argument results in the following theorem.

\begin{theorem}[\cite{nesterovLecturesConvexOptimization2018}]
	For any \(\weights_0\in\reals^d\), any \(n\) such that 
	\[0\le n\le \tfrac12 (d-1),\]
	there exists a convex, smooth function \(f\) with Lipschitz continuous
	derivative such that for any first order method \(\firstOrderMethod\)
	satisfying Assumption~\ref{assmpt: parameter in linear hull of gradients}
	we have
	\begin{subequations}
	\begin{align}
		f(\weights_n) - \inf_\weights f(\weights)
		&\ge \frac{3\ubound \|\weights_0 - \weights^*\|^2}{32(n+1)^2} \\
		\|\weights_k -\weights^*\|^2 
		&\ge \frac18 \|\weights_0 - \weights^*\|^2
	\end{align}
	\end{subequations}
	where \(\weights^* = \arg\min_\weights f(\weights)\).
\end{theorem}
\begin{proof}
	See \textcite[Theorem 2.1.7]{nesterovLecturesConvexOptimization2018}
	First we want to make sure that our loss function is actually convex. To
	see this notice that we can write the gradient as
	%
	\begin{align*}
		\nabla \loss(\weights) = \graphLaplacian\weights + (\weights^{(1)} -1) e_1
	\end{align*}
	%
	where \(\stdBasis_i\) are standard basis vectors and \(\graphLaplacian\) 
	is the "Graph Laplacian" for the 
	\fxnote{tikz graph}{undirected graph} \(\graph=(\vertices, \edges)\) with 
	\begin{align*}
		\vertices = \{1,\dots, \dimension\}
		\qquad
		\edges = \{(i, i+1) : 1\le i \le \dimension-1\}
	\end{align*}
	%
	\begin{align*}
		\graphLaplacian^{(i,j)} 
		&= 
		\begin{cases}
			[\text{degree of vertex i}] & i=j\\
			-1 & (i,j)\in\edges \text{ or } (j,i)\in\edges\\
			0 & \text{ else}
		\end{cases}
		\\
		&=
		\begin{pmatrix*}[r]
			1 & -1 & 0  & \cdots & \cdots & 0 \\
			-1 & 2 & -1 & \ddots &  &  \vdots \\ 
			0 & -1 & 2 & \ddots & \ddots & \vdots \\
			\vdots & \ddots & \ddots & \ddots & -1 & 0 \\
			\vdots &  & \ddots & -1 & 2 & -1 \\
			0 & \cdots & \cdots & 0  & -1 & 1
		\end{pmatrix*}
	\end{align*}
	%
	This means our loss function is quadratic which means that our
	hesse matrix \(\nabla L(\weights)\) is a constant \(H\). And it is
	positive definite because
	%
	\begin{align*}
		\langle \weights , H \weights\rangle
		&= \langle \weights, A_G\weights + \weights^{(1)}e_1 \rangle
		= \langle \weights, A_G \weights\rangle + \weights^{(1)}\langle \weights, e_1\rangle
		\\
		&= \sum_{k=1}^{\dimension-1}(\weights^{(k)}-\weights^{(k+1)})^2
		+ (\weights^{(1)})^2
		\ge 0.
	\end{align*}
	%
	The last equality can be verified by taking the derivative of both and
	realizing they are the same, which is sufficient because they are both zero	
	in the origin. We essentially used the fact that our original loss function
	was essentially already a quadratic function except for the constant influx
	at the first tile. And since that is a constant in the derivative it has
	no bearing on the hesse matrix.


\end{proof}

\begin{remark}
	This type of loss function is not unlikely to be encountered in real
	problems. E.g. in reinforcement learning with sparse rewards the estimation
	of the value function over states requires the back-propagation of this
	reward through the states that lead up to it. "Eligibility traces"
	\parencite[Chapter 12]{suttonReinforcementLearningIntroduction2018}
	are an attempt to speed this process up.
\end{remark}

To make our loss function strongly convex we have to add a regularization term
%
\begin{align*}
	\loss(\weights)
	= \frac{\lbound (\kappa -1)}{8} \left[
		(\weights^{(1)}-1)^2
		+ \sum_{k=1}^{\dimension-1} (\weights^{(k)}-\weights^{(k+1)})^2
	\right]
	+ \frac\lbound{2} \| \weights \|^2
\end{align*}

\fxwarning{finish up}

\section{Heuristics}

\subsection{Adagrad}

\subsection{Adadelta}

\subsection{RMSProp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput